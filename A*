import heapq

def astar_short(grid, start, goal):
    R, C = len(grid), len(grid[0])
    h = lambda n: abs(n[0] - goal[0]) + abs(n[1] - goal[1])

    
    open_list = [(0, 0, start, None)]
    g_costs = {start: 0}
    parents = {start: None}

    while open_list:
        f, g, (r, c), _ = heapq.heappop(open_list)

        if (r, c) == goal:
            
            path, curr = [], goal
            while curr: path.append(curr); curr = parents[curr]
            return path[::-1]

        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            neighbor = (nr, nc)

            
            if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] == 0:
                tentative_g = g + 1
                
                if neighbor not in g_costs or tentative_g < g_costs[neighbor]:
                    g_costs[neighbor] = tentative_g
                    parents[neighbor] = (r, c)
                    f_cost = tentative_g + h(neighbor)
                    heapq.heappush(open_list, (f_cost, tentative_g, neighbor, (r, c)))
    
    return None


GRID = [[0, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 0, 0]]
START, GOAL = (0, 0), (4, 4)

path = astar_short(GRID, START, GOAL)
print(f"Path: {path}")
